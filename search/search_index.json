{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Knex (v0.5.0) Knex is a Python library for creating chainable data transformers. Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-knex-v050","text":"Knex is a Python library for creating chainable data transformers.","title":"Welcome to Knex (v0.5.0)"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About Curribus gravis pharetra viro ipso sumpta nondum Lorem markdownum tori maestis portat esse; ore conversa simul! Prima ferro. Patris exhibuere satyrique laborem. adware -= rwMailMail; if (streaming(eide) > right_motion_sequence) { log.lossyStatusCompile(control, eup_finder); } else { modifierFile = chipset(-2, task_party_minisite + spool, logArchitecture + -3); index += 4; widget_num(4, directxIpxAnd, beta); } if (fileDvi(ramPartyDesktop.mode(error), mirrored_ajax_dslam - 4)) { variableLoginVirus(columnFtp, programmingFrequency, 62); pum(installerHfsClient); design += troubleshooting_peopleware_code.url_mouse_drm(scsiAluDma, cifs_adf_architecture, signature_dual_definition); } Optare misero solam mirabile recingor Et naides fronte nostra rubor est sidereum vigore passura precaris. Ferre in temeraria argenteus alter imperat astringi Caenea dum factaque, leve vera in qua in quoniam. Ego remansit tuum demum sic Astypaleia adest foedabis venimus . Raptos ima semper creatis. heap_xslt_compression(srgb); text = cpcBurn(bin.log.nvram(direct_input_cps, nvram_pmu), computer( macro_copy, trim_surge_supercomputer, mips_language) + 4); var ccd = switch_bios_shortcut.desktop(control(insertion.edutainment( megabit), bar_guid, native_header(active_standby, system_cmos_mirrored))); Oras silva Numen in videri umquam contempto ab totis anguigenae non, Agenore. Non collo. Cur ut sacerdos resolutis iamdudum, siste cuncta, his ullos atque lenius in isto. Lacus sulphura auras tantummodo est cursu Visus male Crimine dolores Quamquam ulvae et contigit nec simus, insequitur heros, ut. Quae sed enim, et se non, mare tenaci. Posse Aeacon movet: es habebat cacumen feros. Foliis palmis! In etiam Naryciusque quem simul genitor dimittit falsoque plangore, numen est summa sternuntur quid trahens postquam.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#curribus-gravis-pharetra-viro-ipso-sumpta-nondum","text":"Lorem markdownum tori maestis portat esse; ore conversa simul! Prima ferro. Patris exhibuere satyrique laborem. adware -= rwMailMail; if (streaming(eide) > right_motion_sequence) { log.lossyStatusCompile(control, eup_finder); } else { modifierFile = chipset(-2, task_party_minisite + spool, logArchitecture + -3); index += 4; widget_num(4, directxIpxAnd, beta); } if (fileDvi(ramPartyDesktop.mode(error), mirrored_ajax_dslam - 4)) { variableLoginVirus(columnFtp, programmingFrequency, 62); pum(installerHfsClient); design += troubleshooting_peopleware_code.url_mouse_drm(scsiAluDma, cifs_adf_architecture, signature_dual_definition); }","title":"Curribus gravis pharetra viro ipso sumpta nondum"},{"location":"about/#optare-misero-solam-mirabile-recingor","text":"Et naides fronte nostra rubor est sidereum vigore passura precaris. Ferre in temeraria argenteus alter imperat astringi Caenea dum factaque, leve vera in qua in quoniam. Ego remansit tuum demum sic Astypaleia adest foedabis venimus . Raptos ima semper creatis. heap_xslt_compression(srgb); text = cpcBurn(bin.log.nvram(direct_input_cps, nvram_pmu), computer( macro_copy, trim_surge_supercomputer, mips_language) + 4); var ccd = switch_bios_shortcut.desktop(control(insertion.edutainment( megabit), bar_guid, native_header(active_standby, system_cmos_mirrored)));","title":"Optare misero solam mirabile recingor"},{"location":"about/#oras-silva","text":"Numen in videri umquam contempto ab totis anguigenae non, Agenore. Non collo. Cur ut sacerdos resolutis iamdudum, siste cuncta, his ullos atque lenius in isto. Lacus sulphura auras tantummodo est cursu Visus male Crimine dolores Quamquam ulvae et contigit nec simus, insequitur heros, ut. Quae sed enim, et se non, mare tenaci. Posse Aeacon movet: es habebat cacumen feros. Foliis palmis! In etiam Naryciusque quem simul genitor dimittit falsoque plangore, numen est summa sternuntur quid trahens postquam.","title":"Oras silva"},{"location":"parsers-reference/","text":"Append ( Parser ) Append value to end of string __init__ ( self , suffix = '' , * args , ** kwargs ) special Initialize Append class. Parameters: Name Type Description Default suffix str Suffix to append to end of string. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , suffix = \"\" , * args , ** kwargs ): \"\"\"Initialize Append class. Args: suffix (str, optional): Suffix to append to end of string. Defaults to \"\". \"\"\" self . suffix = suffix super () . __init__ ( * args , ** kwargs ) process ( self ) Append input with suffix. Returns: Type Description str Appended string. Source code in knex/parsers.py def process ( self ): \"\"\"Append input with suffix. Returns: str: Appended string. \"\"\" if self . raise_exception : return self . input + self . suffix try : return self . input + self . suffix except Exception as e : self . error = True return str ( e ) Base64Decode ( Parser ) Base64 decode a string process ( self ) Process a base64 encoded string, and return its decoded value. Returns: Type Description [type] [description] Source code in knex/parsers.py def process ( self ): \"\"\"Process a base64 encoded string, and return its decoded value. Returns: [type]: [description] \"\"\" if self . raise_exception : return base64 . b64decode ( self . input ) . decode () try : return base64 . b64decode ( self . input ) . decode () except Exception as e : self . error = True return str ( e ) Base64Encode ( Parser ) Base64 encode a string process ( self ) Process a string and return its base64 encoded value. Returns: Type Description str Base64 encoded string in ascii Source code in knex/parsers.py def process ( self ): \"\"\"Process a string and return its base64 encoded value. Returns: str: Base64 encoded string in ascii \"\"\" if self . raise_exception : return base64 . b64encode ( self . input . encode ()) . decode ( \"ascii\" ) try : return base64 . b64encode ( self . input . encode ()) . decode ( \"ascii\" ) except Exception as e : self . error = True return str ( e ) Concat ( Parser ) Concatinate string with optional prefix and suffix __init__ ( self , prefix = '' , suffix = '' , * args , ** kwargs ) special Initialize Concat class. Parameters: Name Type Description Default prefix str Prefix to append to front of input. Defaults to \"\". '' suffix str Suffix to append to end of input. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , prefix = \"\" , suffix = \"\" , * args , ** kwargs ): \"\"\"Initialize Concat class. Args: prefix (str, optional): Prefix to append to front of input. Defaults to \"\". suffix (str, optional): Suffix to append to end of input. Defaults to \"\". \"\"\" self . prefix = prefix self . suffix = suffix super () . __init__ ( * args , ** kwargs ) process ( self ) Process input string and concatinate with prefix and suffix. Returns: Type Description str Concatinated string. Source code in knex/parsers.py def process ( self ): \"\"\"Process input string and concatinate with prefix and suffix. Returns: str: Concatinated string. \"\"\" if self . raise_exception : return self . prefix + self . input + self . suffix try : return self . prefix + self . input + self . suffix except Exception as e : self . error = True return str ( e ) Count ( Parser ) Count the number of items in an iterable process ( self ) Counts the number of items in an iterable. Returns: Type Description int The number of items found. Source code in knex/parsers.py def process ( self ): \"\"\"Counts the number of items in an iterable. Returns: int: The number of items found. \"\"\" if self . raise_exception : return len ( self . input ) try : return len ( self . input ) except Exception as e : self . error = True return str ( e ) FirstElement ( Parser ) Get first element of iterable process ( self ) Get first element of input iterable. Returns: Type Description Any The first element of the input iterable. Source code in knex/parsers.py def process ( self ): \"\"\"Get first element of input iterable. Returns: Any: The first element of the input iterable. \"\"\" if self . raise_exception : return self . input [ 0 ] try : return self . input [ 0 ] except Exception as e : self . error = True return str ( e ) GetField ( Parser ) Get the value of a dictionary by key __init__ ( self , field , * args , ** kwargs ) special Initialize GetField class. Parameters: Name Type Description Default field str The key name to fetch. required Source code in knex/parsers.py def __init__ ( self , field , * args , ** kwargs ): \"\"\"Initialize GetField class. Args: field (str): The key name to fetch. \"\"\" self . field = field super () . __init__ ( * args , ** kwargs ) process ( self ) Fetches the value in a dict given the provided key. Returns: Type Description Any The value of the provided key in the input dictionary. Source code in knex/parsers.py def process ( self ): \"\"\"Fetches the value in a dict given the provided key. Returns: Any: The value of the provided key in the input dictionary. \"\"\" if self . raise_exception : return self . input [ self . field ] try : return self . input [ self . field ] except Exception as e : self . error = True return str ( e ) GetIndex ( Parser ) Gets an element of an iterable like a list or set __init__ ( self , idx , * args , ** kwargs ) special Initialize by providing the index of the element to return. Parameters: Name Type Description Default idx int Index of the element to fetch from the iterable required Source code in knex/parsers.py def __init__ ( self , idx , * args , ** kwargs ): \"\"\"Initialize by providing the index of the element to return. Args: idx (int): Index of the element to fetch from the iterable \"\"\" self . idx = idx super () . __init__ ( * args , ** kwargs ) # self.args = self.get_args() process ( self ) Fetches the value of the index of the iterable given in as input. Returns: Type Description Any The value contained in the iterable at the provided index. Source code in knex/parsers.py def process ( self ): \"\"\"Fetches the value of the index of the iterable given in as input. Returns: Any: The value contained in the iterable at the provided index. \"\"\" if self . raise_exception : return self . input [ self . idx ] try : return self . input [ self . idx ] except Exception as e : self . error = True return str ( e ) IndexOf ( Parser ) Find index of value in a list, or return -1 if not found __init__ ( self , value = '' , * args , ** kwargs ) special Initialize by providing a value to search Parameters: Name Type Description Default value str Value to search for. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , value = \"\" , * args , ** kwargs ): \"\"\"Initialize by providing a value to search Args: value (str, optional): Value to search for. Defaults to \"\". \"\"\" self . value = value super () . __init__ ( * args , ** kwargs ) process ( self ) Find index of value in list Exceptions: Type Description TypeError TypeError if input is not a list Returns: Type Description int Index of value found, or -1 if value not found Source code in knex/parsers.py def process ( self ): \"\"\"Find index of value in list Raises: TypeError: TypeError if input is not a list Returns: int: Index of value found, or -1 if value not found \"\"\" if self . raise_exception : if not isinstance ( self . input , list ): raise TypeError ( \"Input value must be list\" ) for idx , val in enumerate ( self . input ): if val == self . value : return idx return - 1 try : if not isinstance ( self . input , list ): raise TypeError ( \"Input value must be list\" ) for idx , val in enumerate ( self . input ): if val == self . value : return idx return - 1 except Exception as e : self . error = True return str ( e ) IpNetwork ( Parser ) Calculates the Network Address of a given IP address in CIDR notation process ( self ) Calculate network address and prefix given a CIDR notated IPv4 address. Returns: Type Description str Network address and prefix length in CIDR notation (e.g. 10.0.0.0/24) Source code in knex/parsers.py def process ( self ): \"\"\"Calculate network address and prefix given a CIDR notated IPv4 address. Returns: str: Network address and prefix length in CIDR notation (e.g. 10.0.0.0/24) \"\"\" if self . raise_exception : return str ( IPv4Interface ( self . input ) . network ) try : return str ( IPv4Interface ( self . input ) . network ) except Exception as e : self . error = True return str ( e ) Join ( Parser ) Join a list strings together __init__ ( self , separator = '' , * args , ** kwargs ) special Initialize by passing a separator value Parameters: Name Type Description Default separator str Insert value in between items. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , separator = \"\" , * args , ** kwargs ): \"\"\"Initialize by passing a separator value Args: separator (str, optional): Insert value in between items. Defaults to \"\". \"\"\" self . separator = separator super () . __init__ ( * args , ** kwargs ) process ( self ) Concatenate list of strings Exceptions: Type Description TypeError Returned if input is not list Returns: Type Description str Concatenated string separated by optional separator Source code in knex/parsers.py def process ( self ): \"\"\"Concatenate list of strings Raises: TypeError: Returned if input is not list Returns: str: Concatenated string separated by optional separator \"\"\" if self . raise_exception : return self . _join () try : return self . _join () except Exception as e : self . error = True return str ( e ) LastElement ( Parser ) Get last element of iterable process ( self ) Get last element of the input iterable. Returns: Type Description Any The last element of the input iterable. Source code in knex/parsers.py def process ( self ): \"\"\"Get last element of the input iterable. Returns: Any: The last element of the input iterable. \"\"\" if self . raise_exception : return self . input [ - 1 ] try : return self . input [ - 1 ] except Exception as e : self . error = True return str ( e ) MacAddress ( Parser ) Parse MAC addresses and output in user-defined format __init__ ( self , * args , * , size = 2 , sep = ':' , ** kwargs ) special Initialize by providing size and separator. Parameters: Name Type Description Default size int Group size between separators. Defaults to 2. 2 sep str Separator between octets of the mac address. Defaults to \":\". ':' Source code in knex/parsers.py def __init__ ( self , * args , size = 2 , sep = \":\" , ** kwargs ): \"\"\"Initialize by providing size and separator. Args: size (int, optional): Group size between separators. Defaults to 2. sep (str, optional): Separator between octets of the mac address. Defaults to \":\". \"\"\" self . size = size self . sep = sep super () . __init__ ( * args , ** kwargs ) process ( self ) Parse and format mac address. Returns: Type Description str Mac address in user provided format. Source code in knex/parsers.py def process ( self ): \"\"\"Parse and format mac address. Returns: str: Mac address in user provided format. \"\"\" if self . raise_exception : mac = MacAddr ( self . input ) return mac . format ( size = self . size , sep = self . sep ) try : mac = MacAddr ( self . input ) return mac . format ( size = self . size , sep = self . sep ) except Exception as e : self . error = True return str ( e ) Parser Base Parser object __gt__ ( self , other ) special Greater-than > dunder method overload allowing for the chaining of parsers together. (e.g. Parser > Parser > Parser ) Parameters: Name Type Description Default other Parser The right hand operand being fed into the __gt__ method. ( LeftHandOperand > RightHandOperand ) required Returns: Type Description other Returns the right hand operand after processing is completed. Source code in knex/parsers.py def __gt__ ( self , other ): \"\"\"Greater-than `>` dunder method overload allowing for the chaining of parsers together. (e.g. `Parser > Parser > Parser`) Args: other (Parser): The right hand operand being fed into the `__gt__` method. (`LeftHandOperand > RightHandOperand`) Returns: other: Returns the right hand operand after processing is completed. \"\"\" other . raise_exception = self . raise_exception other . input = self . process () other . result = other . process () history = OrderedDict () history [ \"parser\" ] = str ( type ( other ) . __name__ ) history [ \"input\" ] = other . input history [ \"args\" ] = other . get_args () history [ \"error\" ] = other . error history [ \"output\" ] = other . result if hasattr ( self , \"history\" ) and self . history is not None : other . history = copy ( self . history ) other . history . append ( history ) else : other . history = [ history ] return other __init__ ( self , input_data = None , raise_exception = False , * args , ** kwargs ) special Base parser object. This does not need to be called as an end user of this library. Parameters: Name Type Description Default input_data Any Input to the parser. Defaults to None. None raise_exception bool Whether or not to raise a proper python exception if there is a parsing failure. Defaults to False. False Source code in knex/parsers.py def __init__ ( self , input_data = None , raise_exception = False , * args , ** kwargs ): \"\"\"Base parser object. This does not need to be called as an end user of this library. Args: input_data (Any, optional): Input to the parser. Defaults to None. raise_exception (bool, optional): Whether or not to raise a proper python exception if there is a parsing failure. Defaults to False. \"\"\" self . input = input_data self . raise_exception = raise_exception self . result = None self . args = None self . error = False super () . __init__ ( * args , ** kwargs ) get_args ( self ) Get arguments passed into the parser Returns: Type Description dict All arguments passed in, and their values. Source code in knex/parsers.py def get_args ( self ): \"\"\"Get arguments passed into the parser Returns: dict: All arguments passed in, and their values. \"\"\" args = copy ( self . __dict__ ) args . pop ( \"input\" ) args . pop ( \"result\" ) args . pop ( \"args\" ) args . pop ( \"error\" ) args . pop ( \"raise_exception\" ) try : args . pop ( \"history\" ) except KeyError : pass return args process ( self ) Process method. Takes input, and trasforms it. Returns: Type Description Any Output from the transformation. Source code in knex/parsers.py def process ( self ): \"\"\"Process method. Takes input, and trasforms it. Returns: Any: Output from the transformation. \"\"\" return self . input RegexExtractAll ( Parser ) Extract all matches from a string given a regex pattern __init__ ( self , pattern , * args , ** kwargs ) special Extract all matches from a string given a regex pattern Parameters: Name Type Description Default pattern str Regular expression pattern (not compiled) required Source code in knex/parsers.py def __init__ ( self , pattern , * args , ** kwargs ): \"\"\"Extract all matches from a string given a regex pattern Args: pattern (str): Regular expression pattern (not compiled) \"\"\" self . pattern = pattern super () . __init__ ( * args , ** kwargs ) process ( self ) Process string with regex pattern and return matches or None. Returns: Type Description list, None A list of matches or None if no matches found. Source code in knex/parsers.py def process ( self ): \"\"\"Process string with regex pattern and return matches or None. Returns: list, None: A list of matches or None if no matches found. \"\"\" if self . raise_exception : return re . findall ( self . pattern , self . input ) try : return re . findall ( self . pattern , self . input ) except Exception as e : self . error = True return str ( e ) Split ( Parser ) Split a string into a list __init__ ( self , delimeter = ' ' , * args , ** kwargs ) special Initialize Split class Parameters: Name Type Description Default delimeter str Delimiter for which to split string with. Defaults to \" \". ' ' Source code in knex/parsers.py def __init__ ( self , delimeter = \" \" , * args , ** kwargs ): \"\"\"Initialize Split class Args: delimeter (str, optional): Delimiter for which to split string with. Defaults to \" \". \"\"\" self . delimeter = delimeter super () . __init__ ( * args , ** kwargs ) # self.args = self.get_args() process ( self ) Splits string into its parts. Returns: Type Description list A list of parts of the original input. Source code in knex/parsers.py def process ( self ): \"\"\"Splits string into its parts. Returns: list: A list of parts of the original input. \"\"\" if self . raise_exception : return self . input . split ( self . delimeter ) try : return self . input . split ( self . delimeter ) except Exception as e : self . error = True return str ( e ) Start ( Parser ) Starting parser object. __init__ ( self , input_data , * args , ** kwargs ) special Starting parser object. All transformations must start with the Start object. Parameters: Name Type Description Default input_data Any Any form of input that is to be parsed so long as it is a simple data type. (e.g. numbers, sequences, dicts, sets, etc.) required Source code in knex/parsers.py def __init__ ( self , input_data , * args , ** kwargs ): \"\"\"Starting parser object. All transformations must start with the Start object. Args: input_data (Any): Any form of input that is to be parsed so long as it is a simple data type. (e.g. numbers, sequences, dicts, sets, etc.) \"\"\" super () . __init__ ( input_data , * args , ** kwargs ) self . result = self . input self . args = self . get_args () TextFSMParse ( Parser ) Parse text using TextFSM parser __init__ ( self , template , * args , * , fmt = 'dict' , ** kwargs ) special Initialize class by providing a template as a string. Parameters: Name Type Description Default template str TextFSM template string (not a file handle object as TextFSM usually requires) required fmt str Output format. dict format will return a list of dicts, but native format will return the native TextFSM format. Options are dict or native . Defaults to dict . 'dict' Source code in knex/parsers.py def __init__ ( self , template , * args , fmt = \"dict\" , ** kwargs ): \"\"\"Initialize class by providing a template as a string. Args: template (str): TextFSM template string (not a file handle object as TextFSM usually requires) fmt (str, optional): Output format. `dict` format will return a list of dicts, \\ but `native` format will return the native TextFSM format. Options are `dict` or `native`. Defaults to `dict`. \"\"\" self . template = template self . fmt = fmt if fmt == \"dict\" else \"native\" super () . __init__ ( * args , ** kwargs ) process ( self ) Parse text with TextFSM parser. Returns: Type Description list Native TextFSM parsed data in dict or native format. Source code in knex/parsers.py def process ( self ): \"\"\"Parse text with TextFSM parser. Returns: list: Native TextFSM parsed data in `dict` or `native` format. \"\"\" if self . raise_exception : return self . _parse () try : return self . _parse () except Exception as e : self . error = True return str ( e ) ToLower ( Parser ) Convert a string to lower case process ( self ) Convert string to lower case. Returns: Type Description str Lower cased string. Source code in knex/parsers.py def process ( self ): \"\"\"Convert string to lower case. Returns: str: Lower cased string. \"\"\" if self . raise_exception : return self . input . lower () try : return self . input . lower () except Exception as e : self . error = True return str ( e ) ToUpper ( Parser ) Convert string to upper case process ( self ) Process an input string and convert to upper case. Returns: Type Description str Upper cased string. Source code in knex/parsers.py def process ( self ): \"\"\"Process an input string and convert to upper case. Returns: str: Upper cased string. \"\"\" if self . raise_exception : return self . input . upper () try : return self . input . upper () except Exception as e : self . error = True return str ( e )","title":"Parsers"},{"location":"parsers-reference/#knex.parsers.Append","text":"Append value to end of string","title":"Append"},{"location":"parsers-reference/#knex.parsers.Append.__init__","text":"Initialize Append class. Parameters: Name Type Description Default suffix str Suffix to append to end of string. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , suffix = \"\" , * args , ** kwargs ): \"\"\"Initialize Append class. Args: suffix (str, optional): Suffix to append to end of string. Defaults to \"\". \"\"\" self . suffix = suffix super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.Append.process","text":"Append input with suffix. Returns: Type Description str Appended string. Source code in knex/parsers.py def process ( self ): \"\"\"Append input with suffix. Returns: str: Appended string. \"\"\" if self . raise_exception : return self . input + self . suffix try : return self . input + self . suffix except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Base64Decode","text":"Base64 decode a string","title":"Base64Decode"},{"location":"parsers-reference/#knex.parsers.Base64Decode.process","text":"Process a base64 encoded string, and return its decoded value. Returns: Type Description [type] [description] Source code in knex/parsers.py def process ( self ): \"\"\"Process a base64 encoded string, and return its decoded value. Returns: [type]: [description] \"\"\" if self . raise_exception : return base64 . b64decode ( self . input ) . decode () try : return base64 . b64decode ( self . input ) . decode () except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Base64Encode","text":"Base64 encode a string","title":"Base64Encode"},{"location":"parsers-reference/#knex.parsers.Base64Encode.process","text":"Process a string and return its base64 encoded value. Returns: Type Description str Base64 encoded string in ascii Source code in knex/parsers.py def process ( self ): \"\"\"Process a string and return its base64 encoded value. Returns: str: Base64 encoded string in ascii \"\"\" if self . raise_exception : return base64 . b64encode ( self . input . encode ()) . decode ( \"ascii\" ) try : return base64 . b64encode ( self . input . encode ()) . decode ( \"ascii\" ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Concat","text":"Concatinate string with optional prefix and suffix","title":"Concat"},{"location":"parsers-reference/#knex.parsers.Concat.__init__","text":"Initialize Concat class. Parameters: Name Type Description Default prefix str Prefix to append to front of input. Defaults to \"\". '' suffix str Suffix to append to end of input. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , prefix = \"\" , suffix = \"\" , * args , ** kwargs ): \"\"\"Initialize Concat class. Args: prefix (str, optional): Prefix to append to front of input. Defaults to \"\". suffix (str, optional): Suffix to append to end of input. Defaults to \"\". \"\"\" self . prefix = prefix self . suffix = suffix super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.Concat.process","text":"Process input string and concatinate with prefix and suffix. Returns: Type Description str Concatinated string. Source code in knex/parsers.py def process ( self ): \"\"\"Process input string and concatinate with prefix and suffix. Returns: str: Concatinated string. \"\"\" if self . raise_exception : return self . prefix + self . input + self . suffix try : return self . prefix + self . input + self . suffix except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Count","text":"Count the number of items in an iterable","title":"Count"},{"location":"parsers-reference/#knex.parsers.Count.process","text":"Counts the number of items in an iterable. Returns: Type Description int The number of items found. Source code in knex/parsers.py def process ( self ): \"\"\"Counts the number of items in an iterable. Returns: int: The number of items found. \"\"\" if self . raise_exception : return len ( self . input ) try : return len ( self . input ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.FirstElement","text":"Get first element of iterable","title":"FirstElement"},{"location":"parsers-reference/#knex.parsers.FirstElement.process","text":"Get first element of input iterable. Returns: Type Description Any The first element of the input iterable. Source code in knex/parsers.py def process ( self ): \"\"\"Get first element of input iterable. Returns: Any: The first element of the input iterable. \"\"\" if self . raise_exception : return self . input [ 0 ] try : return self . input [ 0 ] except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.GetField","text":"Get the value of a dictionary by key","title":"GetField"},{"location":"parsers-reference/#knex.parsers.GetField.__init__","text":"Initialize GetField class. Parameters: Name Type Description Default field str The key name to fetch. required Source code in knex/parsers.py def __init__ ( self , field , * args , ** kwargs ): \"\"\"Initialize GetField class. Args: field (str): The key name to fetch. \"\"\" self . field = field super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.GetField.process","text":"Fetches the value in a dict given the provided key. Returns: Type Description Any The value of the provided key in the input dictionary. Source code in knex/parsers.py def process ( self ): \"\"\"Fetches the value in a dict given the provided key. Returns: Any: The value of the provided key in the input dictionary. \"\"\" if self . raise_exception : return self . input [ self . field ] try : return self . input [ self . field ] except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.GetIndex","text":"Gets an element of an iterable like a list or set","title":"GetIndex"},{"location":"parsers-reference/#knex.parsers.GetIndex.__init__","text":"Initialize by providing the index of the element to return. Parameters: Name Type Description Default idx int Index of the element to fetch from the iterable required Source code in knex/parsers.py def __init__ ( self , idx , * args , ** kwargs ): \"\"\"Initialize by providing the index of the element to return. Args: idx (int): Index of the element to fetch from the iterable \"\"\" self . idx = idx super () . __init__ ( * args , ** kwargs ) # self.args = self.get_args()","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.GetIndex.process","text":"Fetches the value of the index of the iterable given in as input. Returns: Type Description Any The value contained in the iterable at the provided index. Source code in knex/parsers.py def process ( self ): \"\"\"Fetches the value of the index of the iterable given in as input. Returns: Any: The value contained in the iterable at the provided index. \"\"\" if self . raise_exception : return self . input [ self . idx ] try : return self . input [ self . idx ] except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.IndexOf","text":"Find index of value in a list, or return -1 if not found","title":"IndexOf"},{"location":"parsers-reference/#knex.parsers.IndexOf.__init__","text":"Initialize by providing a value to search Parameters: Name Type Description Default value str Value to search for. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , value = \"\" , * args , ** kwargs ): \"\"\"Initialize by providing a value to search Args: value (str, optional): Value to search for. Defaults to \"\". \"\"\" self . value = value super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.IndexOf.process","text":"Find index of value in list Exceptions: Type Description TypeError TypeError if input is not a list Returns: Type Description int Index of value found, or -1 if value not found Source code in knex/parsers.py def process ( self ): \"\"\"Find index of value in list Raises: TypeError: TypeError if input is not a list Returns: int: Index of value found, or -1 if value not found \"\"\" if self . raise_exception : if not isinstance ( self . input , list ): raise TypeError ( \"Input value must be list\" ) for idx , val in enumerate ( self . input ): if val == self . value : return idx return - 1 try : if not isinstance ( self . input , list ): raise TypeError ( \"Input value must be list\" ) for idx , val in enumerate ( self . input ): if val == self . value : return idx return - 1 except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.IpNetwork","text":"Calculates the Network Address of a given IP address in CIDR notation","title":"IpNetwork"},{"location":"parsers-reference/#knex.parsers.IpNetwork.process","text":"Calculate network address and prefix given a CIDR notated IPv4 address. Returns: Type Description str Network address and prefix length in CIDR notation (e.g. 10.0.0.0/24) Source code in knex/parsers.py def process ( self ): \"\"\"Calculate network address and prefix given a CIDR notated IPv4 address. Returns: str: Network address and prefix length in CIDR notation (e.g. 10.0.0.0/24) \"\"\" if self . raise_exception : return str ( IPv4Interface ( self . input ) . network ) try : return str ( IPv4Interface ( self . input ) . network ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Join","text":"Join a list strings together","title":"Join"},{"location":"parsers-reference/#knex.parsers.Join.__init__","text":"Initialize by passing a separator value Parameters: Name Type Description Default separator str Insert value in between items. Defaults to \"\". '' Source code in knex/parsers.py def __init__ ( self , separator = \"\" , * args , ** kwargs ): \"\"\"Initialize by passing a separator value Args: separator (str, optional): Insert value in between items. Defaults to \"\". \"\"\" self . separator = separator super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.Join.process","text":"Concatenate list of strings Exceptions: Type Description TypeError Returned if input is not list Returns: Type Description str Concatenated string separated by optional separator Source code in knex/parsers.py def process ( self ): \"\"\"Concatenate list of strings Raises: TypeError: Returned if input is not list Returns: str: Concatenated string separated by optional separator \"\"\" if self . raise_exception : return self . _join () try : return self . _join () except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.LastElement","text":"Get last element of iterable","title":"LastElement"},{"location":"parsers-reference/#knex.parsers.LastElement.process","text":"Get last element of the input iterable. Returns: Type Description Any The last element of the input iterable. Source code in knex/parsers.py def process ( self ): \"\"\"Get last element of the input iterable. Returns: Any: The last element of the input iterable. \"\"\" if self . raise_exception : return self . input [ - 1 ] try : return self . input [ - 1 ] except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.MacAddress","text":"Parse MAC addresses and output in user-defined format","title":"MacAddress"},{"location":"parsers-reference/#knex.parsers.MacAddress.__init__","text":"Initialize by providing size and separator. Parameters: Name Type Description Default size int Group size between separators. Defaults to 2. 2 sep str Separator between octets of the mac address. Defaults to \":\". ':' Source code in knex/parsers.py def __init__ ( self , * args , size = 2 , sep = \":\" , ** kwargs ): \"\"\"Initialize by providing size and separator. Args: size (int, optional): Group size between separators. Defaults to 2. sep (str, optional): Separator between octets of the mac address. Defaults to \":\". \"\"\" self . size = size self . sep = sep super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.MacAddress.process","text":"Parse and format mac address. Returns: Type Description str Mac address in user provided format. Source code in knex/parsers.py def process ( self ): \"\"\"Parse and format mac address. Returns: str: Mac address in user provided format. \"\"\" if self . raise_exception : mac = MacAddr ( self . input ) return mac . format ( size = self . size , sep = self . sep ) try : mac = MacAddr ( self . input ) return mac . format ( size = self . size , sep = self . sep ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Parser","text":"Base Parser object","title":"Parser"},{"location":"parsers-reference/#knex.parsers.Parser.__gt__","text":"Greater-than > dunder method overload allowing for the chaining of parsers together. (e.g. Parser > Parser > Parser ) Parameters: Name Type Description Default other Parser The right hand operand being fed into the __gt__ method. ( LeftHandOperand > RightHandOperand ) required Returns: Type Description other Returns the right hand operand after processing is completed. Source code in knex/parsers.py def __gt__ ( self , other ): \"\"\"Greater-than `>` dunder method overload allowing for the chaining of parsers together. (e.g. `Parser > Parser > Parser`) Args: other (Parser): The right hand operand being fed into the `__gt__` method. (`LeftHandOperand > RightHandOperand`) Returns: other: Returns the right hand operand after processing is completed. \"\"\" other . raise_exception = self . raise_exception other . input = self . process () other . result = other . process () history = OrderedDict () history [ \"parser\" ] = str ( type ( other ) . __name__ ) history [ \"input\" ] = other . input history [ \"args\" ] = other . get_args () history [ \"error\" ] = other . error history [ \"output\" ] = other . result if hasattr ( self , \"history\" ) and self . history is not None : other . history = copy ( self . history ) other . history . append ( history ) else : other . history = [ history ] return other","title":"__gt__()"},{"location":"parsers-reference/#knex.parsers.Parser.__init__","text":"Base parser object. This does not need to be called as an end user of this library. Parameters: Name Type Description Default input_data Any Input to the parser. Defaults to None. None raise_exception bool Whether or not to raise a proper python exception if there is a parsing failure. Defaults to False. False Source code in knex/parsers.py def __init__ ( self , input_data = None , raise_exception = False , * args , ** kwargs ): \"\"\"Base parser object. This does not need to be called as an end user of this library. Args: input_data (Any, optional): Input to the parser. Defaults to None. raise_exception (bool, optional): Whether or not to raise a proper python exception if there is a parsing failure. Defaults to False. \"\"\" self . input = input_data self . raise_exception = raise_exception self . result = None self . args = None self . error = False super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.Parser.get_args","text":"Get arguments passed into the parser Returns: Type Description dict All arguments passed in, and their values. Source code in knex/parsers.py def get_args ( self ): \"\"\"Get arguments passed into the parser Returns: dict: All arguments passed in, and their values. \"\"\" args = copy ( self . __dict__ ) args . pop ( \"input\" ) args . pop ( \"result\" ) args . pop ( \"args\" ) args . pop ( \"error\" ) args . pop ( \"raise_exception\" ) try : args . pop ( \"history\" ) except KeyError : pass return args","title":"get_args()"},{"location":"parsers-reference/#knex.parsers.Parser.process","text":"Process method. Takes input, and trasforms it. Returns: Type Description Any Output from the transformation. Source code in knex/parsers.py def process ( self ): \"\"\"Process method. Takes input, and trasforms it. Returns: Any: Output from the transformation. \"\"\" return self . input","title":"process()"},{"location":"parsers-reference/#knex.parsers.RegexExtractAll","text":"Extract all matches from a string given a regex pattern","title":"RegexExtractAll"},{"location":"parsers-reference/#knex.parsers.RegexExtractAll.__init__","text":"Extract all matches from a string given a regex pattern Parameters: Name Type Description Default pattern str Regular expression pattern (not compiled) required Source code in knex/parsers.py def __init__ ( self , pattern , * args , ** kwargs ): \"\"\"Extract all matches from a string given a regex pattern Args: pattern (str): Regular expression pattern (not compiled) \"\"\" self . pattern = pattern super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.RegexExtractAll.process","text":"Process string with regex pattern and return matches or None. Returns: Type Description list, None A list of matches or None if no matches found. Source code in knex/parsers.py def process ( self ): \"\"\"Process string with regex pattern and return matches or None. Returns: list, None: A list of matches or None if no matches found. \"\"\" if self . raise_exception : return re . findall ( self . pattern , self . input ) try : return re . findall ( self . pattern , self . input ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Split","text":"Split a string into a list","title":"Split"},{"location":"parsers-reference/#knex.parsers.Split.__init__","text":"Initialize Split class Parameters: Name Type Description Default delimeter str Delimiter for which to split string with. Defaults to \" \". ' ' Source code in knex/parsers.py def __init__ ( self , delimeter = \" \" , * args , ** kwargs ): \"\"\"Initialize Split class Args: delimeter (str, optional): Delimiter for which to split string with. Defaults to \" \". \"\"\" self . delimeter = delimeter super () . __init__ ( * args , ** kwargs ) # self.args = self.get_args()","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.Split.process","text":"Splits string into its parts. Returns: Type Description list A list of parts of the original input. Source code in knex/parsers.py def process ( self ): \"\"\"Splits string into its parts. Returns: list: A list of parts of the original input. \"\"\" if self . raise_exception : return self . input . split ( self . delimeter ) try : return self . input . split ( self . delimeter ) except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.Start","text":"Starting parser object.","title":"Start"},{"location":"parsers-reference/#knex.parsers.Start.__init__","text":"Starting parser object. All transformations must start with the Start object. Parameters: Name Type Description Default input_data Any Any form of input that is to be parsed so long as it is a simple data type. (e.g. numbers, sequences, dicts, sets, etc.) required Source code in knex/parsers.py def __init__ ( self , input_data , * args , ** kwargs ): \"\"\"Starting parser object. All transformations must start with the Start object. Args: input_data (Any): Any form of input that is to be parsed so long as it is a simple data type. (e.g. numbers, sequences, dicts, sets, etc.) \"\"\" super () . __init__ ( input_data , * args , ** kwargs ) self . result = self . input self . args = self . get_args ()","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.TextFSMParse","text":"Parse text using TextFSM parser","title":"TextFSMParse"},{"location":"parsers-reference/#knex.parsers.TextFSMParse.__init__","text":"Initialize class by providing a template as a string. Parameters: Name Type Description Default template str TextFSM template string (not a file handle object as TextFSM usually requires) required fmt str Output format. dict format will return a list of dicts, but native format will return the native TextFSM format. Options are dict or native . Defaults to dict . 'dict' Source code in knex/parsers.py def __init__ ( self , template , * args , fmt = \"dict\" , ** kwargs ): \"\"\"Initialize class by providing a template as a string. Args: template (str): TextFSM template string (not a file handle object as TextFSM usually requires) fmt (str, optional): Output format. `dict` format will return a list of dicts, \\ but `native` format will return the native TextFSM format. Options are `dict` or `native`. Defaults to `dict`. \"\"\" self . template = template self . fmt = fmt if fmt == \"dict\" else \"native\" super () . __init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"parsers-reference/#knex.parsers.TextFSMParse.process","text":"Parse text with TextFSM parser. Returns: Type Description list Native TextFSM parsed data in dict or native format. Source code in knex/parsers.py def process ( self ): \"\"\"Parse text with TextFSM parser. Returns: list: Native TextFSM parsed data in `dict` or `native` format. \"\"\" if self . raise_exception : return self . _parse () try : return self . _parse () except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.ToLower","text":"Convert a string to lower case","title":"ToLower"},{"location":"parsers-reference/#knex.parsers.ToLower.process","text":"Convert string to lower case. Returns: Type Description str Lower cased string. Source code in knex/parsers.py def process ( self ): \"\"\"Convert string to lower case. Returns: str: Lower cased string. \"\"\" if self . raise_exception : return self . input . lower () try : return self . input . lower () except Exception as e : self . error = True return str ( e )","title":"process()"},{"location":"parsers-reference/#knex.parsers.ToUpper","text":"Convert string to upper case","title":"ToUpper"},{"location":"parsers-reference/#knex.parsers.ToUpper.process","text":"Process an input string and convert to upper case. Returns: Type Description str Upper cased string. Source code in knex/parsers.py def process ( self ): \"\"\"Process an input string and convert to upper case. Returns: str: Upper cased string. \"\"\" if self . raise_exception : return self . input . upper () try : return self . input . upper () except Exception as e : self . error = True return str ( e )","title":"process()"}]}